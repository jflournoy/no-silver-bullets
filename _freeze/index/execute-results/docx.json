{
  "hash": "f4455c32f7efc759e28998a5c190bd21",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: Understanding Technology Team Velocity at Scale\nauthor:\n  - name: John Flournoy\n#    orcid: 0000-0002-0760-5497\n    #   - Investigation\n    #   - Project administration\n    #   - Software\n    #   - Visualization\n    corresponding: true\n    email: john-flournoy@pluralsight.com\n    # roles:\n    affiliation:\n      name: Pluralsight\n      city: Draper, UT\n      country: USA\n# keywords:\nabstract: |\n  Things\nplain-language-summary: |\n  Other things\nkey-points:\n  - A point\ndate: last-modified\nbibliography: references.bib\nnumber-sections: true\nacm-metadata:\n  # comment this out to make submission anonymous\n  \n  # if uncommented, this produces a teaser figure\n  # \n  # anonymous: true\n  # comment this out to build a draft version\n  final: false\n  # comment this out to specify detailed document options\n  # acmart-options: sigconf, review  \n  # acm preamble information\n  copyright-year: 2024\n  acm-year: 2024\n  copyright: acmlicensed\n  doi: XXXXXXX.XXXXXXX\n  conference-acronym: \"Conference acronym 'XX\"\n  conference-name: |\n    Make sure to enter the correct\n    conference title from your rights confirmation email\n  conference-date: June 03--05, 2018\n  conference-location: Woodstock, NY\n  price: \"15.00\"\n  isbn: 978-1-4503-XXXX-X/18/06\n  # if present, replaces the list of authors in the page header.\n  shortauthors: Trovato et al.\n  # Please copy and paste the code instead of the example below.\n  # The code below is generated by the tool at http://dl.acm.org/ccs.cfm.\n  ccs: |\n        \\begin{CCSXML}\n        <ccs2012>\n           <concept>\n               <concept_id>10002944.10011123.10010912</concept_id>\n               <concept_desc>General and reference~Empirical studies</concept_desc>\n               <concept_significance>500</concept_significance>\n               </concept>\n         </ccs2012>\n        \\end{CCSXML}\n        \n        \\ccsdesc[500]{General and reference~Empirical studies}\n  keywords:\n    - productivity\n    - cycle time\n    - collaboration\n    - individual differences\n    - within-person variation\n  # teaser:\n  #   image: sampleteaser\n  #   caption: figure caption\n  #   description: teaser description   \neditor: \n  markdown: \n    wrap: 72\n---\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\n# Function to check if we're running in a GitHub Action\nis_github_action <- function() {\n  Sys.getenv(\"GITHUB_ACTIONS\") == \"true\"\n}\n\n# Set custom library path if running locally\nif (!is_github_action()) {\n  .libPaths('/home/rstudio/R/x86_64-pc-linux-gnu-library/4.3/')\n}\n\nlibrary(ggplot2)\nlibrary(marginaleffects)\nlibrary(brms)\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nLoading required package: Rcpp\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nLoading 'brms' package (version 2.21.6). Useful instructions\ncan be found by typing help('brms'). A more detailed introduction\nto the package is available through vignette('brms_overview').\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\n\nAttaching package: 'brms'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nThe following object is masked from 'package:stats':\n\n    ar\n```\n\n\n:::\n\n```{.r .cell-code .hidden}\nlibrary(rstan)\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nLoading required package: StanHeaders\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\n\nrstan version 2.35.0.9000 (Stan version 2.35.0)\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nFor execution on a local, multicore CPU with excess RAM we recommend calling\noptions(mc.cores = parallel::detectCores()).\nTo avoid recompilation of unchanged Stan programs, we recommend calling\nrstan_options(auto_write = TRUE)\nFor within-chain threading using `reduce_sum()` or `map_rect()` Stan functions,\nchange `threads_per_chain` option:\nrstan_options(threads_per_chain = 1)\n```\n\n\n:::\n\n```{.r .cell-code .hidden}\nlibrary(tidybayes)\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\n\nAttaching package: 'tidybayes'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nThe following objects are masked from 'package:brms':\n\n    dstudent_t, pstudent_t, qstudent_t, rstudent_t\n```\n\n\n:::\n\n```{.r .cell-code .hidden}\nlibrary(rlang)\nlibrary(sjPlot)\n```\n\n::: {.cell-output .cell-output-stderr .hidden}\n\n```\nLearn more about sjPlot with 'browseVignettes(\"sjPlot\")'.\n```\n\n\n:::\n\n```{.r .cell-code .hidden}\nlibrary(ggnewscale)\n\nplot_marginal_effect <- function(x, condition, trans.y = NULL, trans.x = NULL, patchwork_args = list(), ...){\n  require(patchwork)\n  require(rlang)\n  s_to_day <- \\(x) return(x / (60*60*24))\n  # Extract the formula terms\n  terms_object <- attr(model.frame(x), \"terms\")\n  # Get the variables attribute (which includes the response variable)\n  response_variable <- as.character(attr(terms_object, \"variables\"))[2]\n  max_resp <- quantile(x$data[[response_variable]], p = .95)\n  coords <- s_to_day(c(0, max_resp))\n  condition_list <- unique(list(condition, rev(condition)))\n  p <- lapply(condition_list, \\(c) {\n    pp <- marginaleffects::plot_predictions(x, condition = c, re_formula = NA, trans = s_to_day, ...) + \n      scale_color_discrete(labels = function(b) round(as.numeric(b), 2), aesthetics = c('fill', 'color')) + \n      coord_cartesian(y = coords) + \n      theme_minimal()\n  \n    legend_name_auto <- ggplot_build(pp)$plot$labels$fill\n    legend_list <- list(y = 'Median Cycle Time (days)')\n    if (!is.null(legend_name_auto)) {\n      legend_name_auto <- abbreviate(gsub('_', ' ', legend_name_auto), minlength = 8)\n      legend_list <- c(legend_list, list(fill = legend_name_auto, color = legend_name_auto))\n    }\n  \n    pp <- pp + do.call(labs, legend_list)\n    \n    return(pp)\n  })\n  \n  if(!is.null(trans.y)){\n    p <- lapply(p, \\(pp) pp + scale_y_continuous(trans = trans.y))\n  }\n  if(!is.null(trans.x)){\n    p <- lapply(p, \\(pp) pp + scale_x_continuous(trans = trans.x))\n  }\n  default_patchwork <- list(nrow = 1)\n  p <- do.call(patchwork::wrap_plots, c(list(p), modifyList(default_patchwork, patchwork_args)))\n  return(p)\n}\n\nbrms_to_draws <- function(x, variables){\n  x <- x$fit@sim$samples\n  x_subsamples <- lapply(x, \\(x) x[, variables])\n  x_draws <- posterior::as_draws(x_subsamples)\n  return(x_draws)\n}\n\ntheme_clean <- theme_minimal() + \n  theme(\n    strip.text.x = element_blank(), \n    axis.text.x = element_blank(),\n    axis.ticks.x = element_blank(),\n    panel.grid.major.x = element_blank(),\n    panel.grid.minor.x = element_blank(),\n    panel.grid.major.y = element_blank(),\n    panel.grid.minor.y = element_blank(), \n    panel.spacing = unit(0, 'lines')\n  )\n```\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Introduction\n\nUnderstanding the factors that affect the productivity of software developers offers organizations the knowledge to deliver value to users, maintain competitiveness, and improve developer experience. Indeed, whether software is the an organizations primary product, or whether internal software engineering enables other end goals (such as in the pharmaceutical industry), the productivity of developers is increasingly the foundation on which all other activities are built. \n\nWhile the choice of a productivity metric is itself a question that has produced a large literature, this analysis focuses on cycle time, which is often used because of its ease and low cost. This report seeks to describe both the impact of several influential factors, as well as describe what cycle time looks like across a wide range of conditions. That is, understanding the variation in cycle time is as important as what influences it on average. We report on cycle time data for a full year, across hundreds of organizations, which allows us to examine fluctuations within a person's workflow as well as different stable tendencies between people.\n\nRQ1. How do common software development process and workplace factors impact productivity? \n\nRQ2. How much between- and within-person variation is there in productivity?\n\n# Background\n\n## Defining productivity\n\nThere is disagreement about what constitutes productivity. Perceptions of what counts as productivity differ across individuals and roles, with managers tending to focus on long-term outcomes and ICs focusing on activity, for example [@storeyHowDevelopersManagers2022]. The scientific literature on this topic has used code-based metrics such as cycle time, commits, or lines of code[@murphy-hillWhatPredictsSoftware2021a]. These have obvious limitations in that the meaning of a particular unit for any of these metrics may be different depending on context \\[cite\\]. Some researches have sought solutions to this problem by asking individuals to rate their own level of, or satisfaction with, productivity [@storeyTheorySoftwareDeveloper2021]. While it is plausible that perceived productivity could indicate productivity _per se_, such a measure is not free from context effects that would impact more \"objective\" metrics, and presents its own set of measurement challenges. \n\nThere is also discussion about the difference in terms of whether we should think about production, productivity, or performance.\n\nIndeed, the discussion to date around productivity reveals what is primarily a philosophical problem: we have not nailed down the necessary and sufficient conditions for something to count as productivity. This is not an easy task, and there are likely several kinds of productivity we may legitimately be interested in. This research project cannot, and will not, attempt to resolve these problems.\n\nIn this analysis, we will examine cycle time, defined as the time between the opening of a ticket and its closure. This duration is an index of many disparate causes, as any developer can easily attest. Nevertheless, it represents a unit of work that has been deemed important to the completion of some larger piece of work.\n\n# Research design and methodology\n\nAll code can be found in the repository for this paper.\n\n## Data Selection and Characteristics\n\nTo examine coding time, task scoping, and collaboration as predictors of cycle time over time, we pulled data from the software metrics tool, Flow. Flow is a software platform that leverages git and ticketing data to track individual, team, and organization-level metrics that can be used as indicators of production, productivity, and performance over time. From Flow, we selected data for analysis if users actively contributed code. The data thus consisted of data from 314 organizations of varying sizes and industries, 9,101 teams, and 37,120 developers.\n\n## Defining Study Variables\n\nUsing the most complete data for each user, we use the mean to aggregate each variable at the month level and the year level (see below for more details specific to each variable). For each predictor, we then subtracted each person's yearly average from their monthly data to produce a within-person deviation variable. This allows us to disaggregate effects on the outcome due to yearly-level individual differences and within-person, month-to-month fluctuations.\n\n***Cycle Time*** This is the dependent variable in these analyses. After computing the cycle time for each closed ticket in seconds, we found the median cycle time for each month for each user using all tickets _opened_ in that month. For example, a ticket opened on the 9th of April, and closed on the 3rd of May would contribute 2,246,400 seconds to the calculation of the median for April.\n\n***Unclosed Tickets*** We were not able to observe the closing date for every ticket given our data collection cutoff of ***DATE***, and so it is plausible that we underestimate the median cycle time in a way that depends in part on how many ticket closing times we do not observe. For this reason, we also computed the proportion of tickets opened in that month that had not been closed by the end of our data collection. For example, any ticket opened in April but not closed by ***DATE*** would count toward the proportion of unclosed tickets for that month.\n\n***Coding Time*** The amount of coding time was summarized as the average number of days per week that a developer made at least one commit. We divided the number of coding days in a month by the total number of days in that month and multiplied by seven to aid in interpretation.\n\n***Total Merged PRs*** Task scoping is a potentially important driver of cycle time. To measure the extent to which smaller chunks of work lead to a completed ticket, we counted the number of merged pull requests for each user for each month.\n\n***Percent Defect Tickets*** Defect tickets represent unplanned work that may interfere with timely completion of planned work. To account for this possibility, for each user, for each month, we computed the proportion of tickets that were defect tickets.\n\n***Degree centrality*** We measured collaboration by calculating degree centrality. To evaluate degree centrality, a metric derived from network analysis, we employed a framework where developers were treated as nodes within the network, and their interactions in the form of Pull Requests (PRs) were regarded as connections. Within this analysis, we measured the degree centrality of each developer by assessing the number of other developers with whom they had collaborated throughout the entirety of 2022. To ensure a normalized assessment, this value was then divided by the total number of developers constituting the organizational network. The calculations were executed using the Python package Networkx. This particular variable serves as an effective proxy for quantifying the extent of collaboration amongst developers.\n\n***Comments per PR*** Another indicator of collaboration is the frequency of comments within PRs. We undertook a comprehensive examination of all PRs that were successfully merged in the year 2022, meticulously calculating the average word count contained within each PR. This served as a valuable measure to gauge the depth of collaboration exhibited during the development and review process.\n\n| Broad Construct | Variable                          | Variable Description                                                 |\n|:-----------------------|:------------------|:------------------------------|\n| Coding Time     | Coding Days per Week              | Avg number of coding days a week                                     |\n| Task Scoping    | Total Merged PRs                  | Total number of merged PRs per developer                             |\n|                 | Percent Defect Tickets            | Percent of all tickets that are defect tickets                       |\n| Collaboration   | Degree Centrality                 | Score based on the number of reviewers a developer has worked with   |\n|                 | Comments per PR                   | Number of comments per pr a developer is the author on               |\n| Productivity    | Cycle Time                        | Avg time from ticket start to end                                    |\n|                 | Proportion unclosed tickets       | Control variable to account for tickets missing cycle time           |\n\n: Construct and variable descriptions {#tbl-constructs}\n\n## Analytic Approach\n\nTo examine coding days per week, merged PRs, defect tickets, degree centrality, and comments per PR as predictors of cycle time over time, we conducted a multilevel conditional growth model. We used a multilevel growth model due to the hierarchical nature of the data, where each time measurement of cycle time is nested within each developer, and each developer is nested within a team. Multilevel growth models take this hierarchical structure into account by modeling within- and between-person level equations (Curran et al., 2010). We coded time as months in 2022 to capture change in cycle time over the course of a full calendar year. To preserve statistical power, we limited the number of time points to four - one point for each quarter of the calendar year. Given that most organizations set quarterly goals at the beginning of each quarter and push to meet those goals at the end of each quarter, we opted to examine data from the middle month of each quarter (February, May, August, and November). This approach allowed us to capture a more stable and realistic trajectory of change over the course of the year.\n\nAs recommended by Singer and Willett (2003), we implemented a three-step procedure. First, we ran an unconditional means model. This model tested for sufficient between group variance to run a multilevel model by calculating intraclass correlation coefficients (ICCs). We then conducted a multilevel conditional growth model, adding a fixed slope representing linear change and nesting individual developers within teams, to assess the effects of time on cycle time (model 1). Finally, to test coding days per week, merged PRs, percent of defect tickets, degree centrality, and comments per PR as predictors of cycle time over time, we conducted a multilevel conditional growth model. In this model, we added the yearly averages of each predictor and their interaction effects with time as time-invariant fixed factors at the individual developer-level (model 2). In this model, significant interaction terms indicate significantly different rates of change in cycle time between groups (Greene, Way, & Pahl, 2006; Taylor et al., 2010; Huang, 2023). The models were fit using restricted maximum likelihood using the lme4 package in R (Bates et al., 2015) and inferential tests for fixed effects were conducted via t-tests (Satterthwaite degrees of freedom) computed using the lmerTest package (Kuznetsova, Brockhoff, & Christensen, 2017).\n\n# Results\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nct_model <- readRDS('cycle_time_full_intx_nlq.rds')\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code .hidden}\nct_model_draws <- brms_to_draws(ct_model, variables = variables(ct_model)[1:37])\nct_model_pars <- parameters::model_parameters(ct_model_draws, centrality = 'median', ci = .95, ci_method = 'hdi')\nmodel_param_table <- kableExtra::kbl(ct_model_pars, digits = 2, format = 'pipe', booktabs = TRUE, tabular = TRUE, caption = \"Model parameter estimates\")\n\nif(knitr::is_html_output()){\n  knitr::knit_print(kableExtra::kable_styling(model_param_table, bootstrap_options = c('striped', 'hover')))\n} else {\n  knitr::knit_print(model_param_table)\n}\n```\n\n::: {.cell-output-display}\n\n\nTable: Model parameter estimates\n\n|Parameter                                                | Median| CI_low| CI_high|   pd|\n|:--------------------------------------------------------|------:|------:|-------:|----:|\n|b_Intercept                                              |  14.34|  14.26|   14.43| 1.00|\n|b_shape_Intercept                                        |   0.12|   0.08|    0.17| 1.00|\n|b_within_quarter_month_num_c                             |  -0.01|  -0.02|    0.00| 0.96|\n|b_team_size_c                                            |   0.00|  -0.05|    0.06| 0.50|\n|b_wi_avg_coding_days_per_week                            |  -0.08|  -0.09|   -0.07| 1.00|\n|b_yr_avg_avg_coding_days_per_week_c                      |  -0.04|  -0.18|    0.10| 0.73|\n|b_wi_total_merged_prs                                    |  -0.01|  -0.02|   -0.01| 1.00|\n|b_yr_avg_total_merged_prs_c                              |   0.00|  -0.15|    0.13| 0.52|\n|b_wi_defect_tickets_pct_indiv                            |   0.00|   0.00|    0.00| 1.00|\n|b_yr_avg_defect_tickets_pct_indiv_c                      |   0.00|  -0.14|    0.14| 0.53|\n|b_wi_degree_centrality_monthly_100                       |   0.00|   0.00|    0.00| 1.00|\n|b_yr_avg_degree_centrality_monthly_100_c                 |   0.00|  -0.13|    0.15| 0.52|\n|b_wi_comments_per_pr                                     |   0.00|   0.00|    0.01| 1.00|\n|b_yr_avg_comments_per_pr_c                               |   0.00|  -0.13|    0.14| 0.51|\n|bs_sq_unclosed_c_1                                       |   0.02|  -0.16|    0.22| 0.60|\n|bs_smonth_num_c_1                                        |  -0.07|  -0.22|    0.10| 0.80|\n|bs_smonth_num_c:team_size_c_1                            |   0.00|  -0.19|    0.17| 0.50|\n|bs_smonth_num_c:team_size_c_2                            |   0.00|   0.00|    0.01| 0.89|\n|bs_smonth_num_c:q_unclosed_c_1                           |   0.14|   0.03|    0.24| 0.99|\n|bs_smonth_num_c:q_unclosed_c_2                           |  -0.04|  -0.12|    0.02| 0.90|\n|bs_smonth_num_c:yr_avg_avg_coding_days_per_week_c_1      |  -0.02|  -0.03|    0.00| 0.96|\n|bs_smonth_num_c:yr_avg_avg_coding_days_per_week_c_2      |  -0.04|  -0.18|    0.09| 0.72|\n|bs_smonth_num_c:yr_avg_total_merged_prs_c_1              |   0.00|  -0.01|    0.00| 0.92|\n|bs_smonth_num_c:yr_avg_total_merged_prs_c_2              |  -0.01|  -0.14|    0.14| 0.54|\n|bs_smonth_num_c:yr_avg_defect_tickets_pct_indiv_c_1      |   0.00|   0.00|    0.00| 0.77|\n|bs_smonth_num_c:yr_avg_defect_tickets_pct_indiv_c_2      |   0.00|  -0.14|    0.14| 0.51|\n|bs_smonth_num_c:yr_avg_degree_centrality_monthly_100_c_1 |   0.00|   0.00|    0.00| 0.68|\n|bs_smonth_num_c:yr_avg_degree_centrality_monthly_100_c_2 |  -0.01|  -0.14|    0.14| 0.53|\n|bs_smonth_num_c:yr_avg_comments_per_pr_c_1               |   0.00|   0.00|    0.00| 0.56|\n|bs_smonth_num_c:yr_avg_comments_per_pr_c_2               |   0.01|  -0.13|    0.15| 0.53|\n|sd_org_id_fac__Intercept                                 |   0.47|   0.42|    0.54| 1.00|\n|sd_org_id_fac__month_num_c                               |   0.03|   0.03|    0.04| 1.00|\n|sd_org_id_fac:user_id_fac__Intercept                     |   0.64|   0.63|    0.66| 1.00|\n|sd_org_id_fac:user_id_fac__month_num_c                   |   0.07|   0.06|    0.07| 1.00|\n|sd_org_id_fac__shape_Intercept                           |   0.28|   0.24|    0.31| 1.00|\n|cor_org_id_fac__Intercept__month_num_c                   |  -0.12|  -0.32|    0.09| 0.87|\n|cor_org_id_fac:user_id_fac__Intercept__month_num_c       |  -0.13|  -0.19|   -0.08| 1.00|\n\n\n:::\n:::\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Limitations\n\nFactors outside our control that organizations can control to increase the reliability and validity of their cycle time data include establishing a systematic approach to ticket use. Even within an organization, individual teams may have different cultures regarding when it is appropriate to open and close a ticket. If one is using cycle time as a metric to guage team velocity, it may be ideal to open and close tickets based on consisten criteria across teams. For example, opening a ticket after a piece of work is completed, and then closing it soon after, does not provide a good measure of how long that work took to complete. Distinguishing ticket types may also help. Here we were able to separate tickets into defect and non-defect tickets, but there are certainly more granular ways of categorizing tickets. These categories, in an analysis like the above, can help ensure the analytic model is comparing like with like. \n\n# Discussion\n\n# Related Work\n\n# Conclusions\n\n# References {.unnumbered}\n\n",
    "supporting": [
      "index_files/figure-docx"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": null,
    "postProcess": false
  }
}